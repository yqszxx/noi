# 第二周：搓揉在一起的一些奇怪东西

既然我们已经掌握了一些高级数据结构，那么我们从本周开始可以讲一些杂的东西了。

我们每周都会把一些奇奇怪怪的东西搓揉到一起（不然一直学同一个东西怕大家学傻了）

## 组合小复习

《组合数学》（机械工业出版社）第2章看完，后面有答案的习题做完。（这本书我手边没有。。所以来问我问题的时候可能需要描述一下题意。。）

如果有时间，第3章除了Ramsey定理外的部分也都看完。有答案的习题做完。

## 一些树相关的数据结构

### dfs序

#### 用途1：维护子树

很显然地，一棵子树在dfs序上一定是连续的一段。因此我们求出dfs序后，很容易就能在数据结构上维护它。

#### 用途2：维护一条到根的链

如果我们对于每个节点，在dfs序中记录$2$次，第一次是入栈的时间，第二次是出栈的时间。对于每个节点的信息，我们在第一次出现时加上，第二次出现时减掉。（当然，这个信息必须满足可减性，比如最值就不能这么做）

这样做，你会发现，一个点到根的路径上的信息，就是在dfs序里，这个点第一次出现位置的前缀和。

经典例题：NOIP2016天天爱跑步

bzoj：`4034`,`3306`

*需要注意的是：如果你用主席树来维护一些事情的话，那么并不需要借助dfs序*

### 树链剖分

树链剖分其实非常简单。总结一下的话是这样的

1. 两遍dfs，求出top,fa,depth,son,size,dfn。

2. 写个求lca，代码如下
```
int lca(int u,int v){
	int fu=top[u],fv=top[v];
	while (fu!=fv){
		if (deep[fu]<deep[fv]) swap(u,v),swap(fu,fv);
		u=fa[top[u]];
		fu=top[u];
	}
	return deep[u]<deep[v]?u:v;
}
```

3. 你可能需要写一个数据结构（如线段树）

4. 对于所有树上操作，你需要单独写一个接口。下面是一个栗子：
```
ll Query(int u,int v){
	int w=lca(u,v);
	ll ret=INF;
    for (;deep[u]>=deep[w];u=fa[top[u]])
		ret=min(ret,st.query(1,max(dfn[top[u]],dfn[w]),dfn[u]));
    for (;deep[v]>=deep[w];v=fa[top[v]])
		ret=min(ret,st.query(1,max(dfn[top[v]],dfn[w]),dfn[v]));
    return ret;
}
```

所以，事实上，我们发现，树链剖分的核心部分就是2个dfs和求lca，而两个dfs是最基本的树形dp。lca的代码又非常短小。

bzoj：`3626`,`3531`,`2243`(选),`4515`(难)

其中，最后一题需要写一个超哥线段树（用来维护折点的一个东西），有兴趣可以学习一个。

### 点分治

对于一类找路径的问题，我们假设强行给树钦定一个根，那么树上所有路径都能被分为$2$类：经过根的、不经过根的。

经过根的，我们可能可以用子树dp处理出一些信息，然后搞一搞（这边的复杂度是$O(n)$的）。

不经过根的，我们可以递归求解每棵子树。

不过很遗憾，当树的深度太深的时候，这个做法的时间复杂度就GG了。

我们发现，每次递归得到的子问题，和他的祖先并没有**任何**关系。

于是我们可以在每一次递归得到新的子问题后，重新钦定一个优秀的根。来减小我们的递归次数。

可以证明的是，每一次我们都选择重心（这个东西我们在点分治里又叫分治中心），可以把递归层数减小到$\log n$级别。

poj：`1741`(模板题)

bzoj：`3697`,`2599`,`2152`,`1758`(难)

注意：如果做bzoj1758不要用网上的单调性做法，那个是错的。老老实实写数据结构。

### 树上问题的一些小总结

1. 一些满足可减性的问题（不带修改），直接求每个点到根的信息。求的时候求u-lca+v-lca即可。
2. 一些满足可加性的问题（不带修改），可以用倍增来解决。
3. 一些子树类问题，可以用数据结构维护dfs序来解决。
4. 一些满足可减性的问题（带修改），可以用dfs序套数据结构来解决。
5. 一些满足可加性的问题（带修改），可以用树链剖分来解决。
6. 一些需要改变树的形态的题，考虑动态树，之后咱们会讲。
7. 路径相关的问题，如果上面的方法和树dp都不能解决的话，不妨考虑点分治。

## 动态规划

### 前言

动态规划本质上我认为是在优化暴力。

在你暴力搜索的时候，你需要记录当前状态的所有信息。

然而，有些信息是有用的，有些信息是冗余的。

当你把有用的信息拿出来，来表示一个状态，然后再搞清楚状态和状态之间的（转移）关系，那么你就设计出了一个动态规划算法。

动态规划的优化有2个角度：优化状态和优化转移（当然还有推倒重来）

优化状态的时候，一般考虑去掉状态表示中冗余的部分，也可能是修改状态表示。

优化转移时，一般有决策单调性和数据结构$2$个方向。（可能还可以用多项式/矩阵乘法/其他有趣的算法来优化）

当然，以上的东西可能都依赖推性质。

### 栗子：背包问题九讲.pdf

可以自己看看，体会体会。都属于非常简单的内容。有时间我也可以讲讲。

### 习题：

说明：DP部分的习题，除非我有特别觉得有趣的题，一般我们在TC SRM上做。

下面是这次的习题：

`548-450`

`549-600`

`550-850`

`552-550`

`553-550`

`555-255`

以上题目随便做，尽可能使你的总得分更高。（停课同学要求：2000；非停课同学要求：1500）

搞TC客户端的教程在这里：http://blog.csdn.net/u011639256/article/details/38167823

网页版TC在这里：http://arena.topcoder.com

（我会客户端，yjq会网页版，问问题的时候可以问对应的人QwQ）