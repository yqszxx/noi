# 第一周：高级数据结构

## 队列、栈、链表

相信大家都会

## 并查集

### 优化

1. 路径压缩

2. 按秩合并（深度小的并到深度大的）

只有写满这2个优化，并查集的复杂度才是严格的alpha的。不过一般我们不写按秩合并。

### 其他

可撤销并查集（不写路径压缩！）（多在写暴力时用到）

### 重要用法

bzoj3211 花神游历各国

这是一个题目名字代表并查集用法的重要栗子。

也就是今年省选D1T2的标算所需要用到的东西。

有点类似于链表（？）

大家可以自行体会。

### 题

（题我都混一起了）

bzoj:`3211`,`4668`,`2054`,`1016`(这题中matrix-tree theory并不是必须的，可以用暴力来代替)

### 选做题

bzoj:`4423`



## 可并堆

### 学习

可以看课件`可并堆.pptx`

### 题

bzoj:`2809`,`2333`,`1455`,`4003`

### 选做题

bzoj:`1078`,`1367`

## 树状数组

### 前缀和、ST表、树状数组、线段树的适用场合

前缀和：不带修改，满足区间可减性。

ST表（这个不是必要的）：不带修改，求区间min,max专用。

树状数组：带**单点**修改，满足区间可减性。

线段树：似乎啥都能做（不支持区间翻转（这个平衡树支持。）），但必须满足区间可加性。

### 常见trick

树状数组上二分（一个log）

异或树状数组（即求前缀异或和）

乘积树状数组（即求前缀积）

带修改求前缀min(max)（要求：修改只降(增)）

一个树状数组支持区间修改单点查询（利用差分化思想！）

两个树状数组支持区间修改区间查询（同样是利用差分化的思想，用途不广）

### 二分

考虑树状数组的原理（求和、查询）。

不懂的可以看我博客上bzoj4415的题解的代码，非常短。

### 求其他东西

简单理解一下就行

min(max)这个需要仔细理解一下。不过不会也没关系，反正线段树也能搞。

### 差分化

如果你要修改一段区间（假设你要区间+delta）。

你可以在这个区间的左端点打个+delta的标记。再在区间右端点+1的位置打个-delta的标记。

当你需要单点查询的时候，要查询的位置的标记前缀和即是这个点的值。

如果你的所有修改操作都先于查询操作，那么你可以用一个数组记录标记，然后打完所有标记后求一遍前缀和。

否则，你可以用树状数组来维护。

差分化较为有用，在树上面对一些问题也能这么做（比如noip2015d2t3）。

### 题

bzoj:`4415`,`4418`

uoj:`180`

## 线段树

### 线段树上二分

比在树状数组上二分应该更直观好理解。

在可持久化线段树求区间k大时，我们在函数式线段树上做的就是这个二分。

或者，换而言之，我们在不可持久化的线段树上做的二分求的是全局k大。

### 线段树合并

实现起来非常暴力，下面是一段代码

```c++
int merge(int x,int y){
	if (!x||!y) return x+y;
	t[x].sum+=t[y].sum;
	t[x].ls=merge(t[x].ls,t[y].ls,cnt);
	t[x].rs=merge(t[x].rs,t[y].rs,cnt);
	return x;
}
```

可以证明它的复杂度是保证的，它甚至比启发式合并更优，能够做到均摊$log\space n$。

### 一个小技巧

当你要维护很多相关联的信息的时候，你做查询操作时可以直接合并，返回节点（面向对象的思想）。

### 题

bzoj:`4592`,`1858`,`2212`

### 选做题

bzoj:`1018`

IOI2017国家集训队清华集训D1T1 《Alice和Bob又在玩游戏》（此题在UOJ和bzoj上都有，建议有博弈论基础、并有一定代码能力的同学做）

## 可持久化

 字面意思：保留历史版本

 一个具体应用：需要维护多维的信息时，可以将一维看成时间

### 特别注意！！

均摊时间复杂度的问题是不支持可持久化的（主要是不支持回退到历史版本）。

一个典型的栗子是splay。

## 可持久化线段树

### 求区间k大

大家可能都会，我就不细讲了，如果不会可以看陈老师的论文。

大致思想就是把每个数的坐标拉出来作为时间轴，然后建立（函数式）可持久化线段树。那么原问题中一段区间就变成了一段时间。然后在上面二分即可。

### 可持久化数组

可持久化数组也可以用可持久化线段树来实现。

### 题

bzoj:`2006`,`4631`,`4408`,`3763`,`3764`